# O(n^2) / O(n) - Recursion w/ Memoization
class Solution:
    def wordBreak(self, s: str, wordDict: List[str], cache = {}) -> bool:
        return self.helper(s, set(wordDict), {})
        
    def helper(self, word, dict, cache):
        if word in cache: return cache[word]
        n = len(word)
        for i in range(1, n+1):
            if word[0:i] in dict:
                if i == n or self.helper(word[i:], dict, cache): 
                    cache[word] = True
                    return True
        cache[word] = False
        return False
        
# O(n^2) / O(n) - DP
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dict, cache, size = set(wordDict), defaultdict(bool), len(s)
        cache[0] = True
        for r in range(1, size+1):
            for l in range(0, r):
                if l in cache and s[l:r] in dict:
                    cache[r] = True
                    break
        return cache[size]
